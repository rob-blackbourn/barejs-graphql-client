{"version":3,"file":"index.min.js","sources":["../../src/fetch-error.js","../../src/graphql-error.js","../../src/event-error.js","../../src/graphql-ws-subscriber.js","../../src/graphql-ws-client.js","../../src/graphql-event-source-client.js","../../src/graphql-event-source-subscriber.js","../../src/graphql-fetch-client.js","../../src/graphql-stream-client.js"],"sourcesContent":["export default class FetchError extends Error {\n  constructor (response, ...params) {\n    super(...params)\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, FetchError)\n    }\n\n    this.name = 'FetchError'\n    this.response = response\n  }\n}\n","export default class GraphQLError extends Error {\n  constructor (details, ...params) {\n    super(...params)\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, GraphQLError)\n    }\n\n    this.details = details\n  }\n}\n","export default class EventError extends Error {\n  constructor (event, ...params) {\n    super(...params)\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, EventError)\n    }\n\n    this.event = event\n  }\n}\n","import GraphQLError from './graphql-error'\nimport EventError from './event-error'\n\nconst GQL = {\n  CONNECTION_INIT: 'connection_init',\n  CONNECTION_ACK: 'connection_ack',\n  CONNECTION_ERROR: 'connection_error',\n  CONNECTION_KEEP_ALIVE: 'ka',\n  START: 'start',\n  STOP: 'stop',\n  CONNECTION_TERMINATE: 'connection_terminate',\n  DATA: 'data',\n  ERROR: 'error',\n  COMPLETE: 'complete'\n}\n\nclass Subscriber {\n  constructor (url, options, callback, protocols = 'graphql-ws') {\n    this.callback = callback\n\n    this.nextId = 1\n    this.subscriptions = new Map()\n    this.webSocket = new WebSocket(url, protocols)\n\n    this.webSocket.onopen = event => {\n      // Initiate the connection\n      this.webSocket.send(JSON.stringify({\n        type: GQL.CONNECTION_INIT,\n        payload: options\n      }))\n    }\n\n    this.webSocket.onclose = event => {\n      // The code 1000 (Normal Closure) is special, and results in no error or payload.\n      const error = event.code === 1000 || event.code === 1005 ? null : new EventError(event)\n      // Notify the subscriber.\n      this.callback(error)\n      // Notify the subscriptions.\n      const callbacks = Array.from(this.subscriptions.values())\n      this.subscriptions.clear()\n      for (const callback of callbacks) {\n        callback(error, null)\n      }\n    }\n\n    this.webSocket.onmessage = this.onMessage.bind(this)\n  }\n\n  subscribe (query, variables, operationName, callback) {\n    const id = (this.nextId++).toString()\n    this.subscriptions.set(id, callback)\n\n    this.webSocket.send(JSON.stringify({\n      type: GQL.START,\n      id,\n      payload: { query, variables, operationName }\n    }))\n\n    // Return the unsubscriber.\n    return () => {\n      this.subscriptions.delete(id)\n\n      this.webSocket.send(JSON.stringify({\n        type: GQL.STOP,\n        id\n      }))\n    }\n  }\n\n  shutdown () {\n    this.webSocket.send(JSON.stringify({\n      type: GQL.CONNECTION_TERMINATE\n    }))\n    this.webSocket.close()\n  }\n\n  onMessage (event) {\n    const data = JSON.parse(event.data)\n\n    switch (data.type) {\n      case GQL.CONNECTION_ACK: {\n        // This is the successful response to GQL.CONNECTION_INIT\n        if (this.callback) {\n          this.callback(null, this.subscribe.bind(this))\n        }\n        break\n      }\n      case GQL.CONNECTION_ERROR: {\n        // This may occur:\n        // 1. In response to GQL.CONNECTION_INIT\n        // 2. In case of parsing errors in the client which will not disconnect.\n        if (this.callback) {\n          this.callback(new GraphQLError(data.payload), this)\n        }\n        break\n      }\n      case GQL.CONNECTION_KEEP_ALIVE: {\n        // This may occur:\n        // 1. After GQL.CONNECTION_ACK,\n        // 2. Periodically to keep the connection alive.\n        break\n      }\n      case GQL.DATA: {\n        // This message is sent after GQL.START to transfer the result of the GraphQL subscription.\n        const callback = this.subscriptions.get(data.id)\n        if (callback) {\n          const error = data.payload.errors ? new GraphQLError(data.payload.errors) : null\n          callback(error, data.payload.data)\n        }\n        break\n      }\n      case GQL.ERROR: {\n        // This method is sent when a subscription fails. This is usually dues to validation errors\n        // as resolver errors are returned in GQL.DATA messages.\n        const callback = this.subscriptions.get(data.id)\n        if (callback) {\n          callback(new GraphQLError(data.payload), null)\n        }\n        break\n      }\n      case GQL.COMPLETE: {\n        // This is sent when the operation is done and no more dta will be sent.\n        const callback = this.subscriptions.get(data.id)\n        if (callback) {\n          this.subscriptions.delete(data.id)\n          // Return a null error and payload to indicate the subscription is closed.\n          callback(null, null)\n        }\n        break\n      }\n    }\n  }\n}\n\nexport default function graphqlWsSubscriber (url, query, variables, operationName, onNext, onError, onComplete) {\n  let unsubscribe = null\n\n  const subscriber = new Subscriber(\n    url,\n    {},\n    (error, subscribe) => {\n      if (!(error || subscribe)) {\n        // Normal closure.\n        onComplete()\n      } else if (error) {\n        onError(error)\n      } else {\n        unsubscribe = subscribe(\n          query,\n          variables,\n          operationName,\n          (errors, data) => {\n            if (!(errors || subscribe)) {\n              // Normal closure\n              onComplete()\n            } else {\n              onNext({ data, errors })\n            }\n          })\n      }\n    },\n    'graphql-ws')\n\n  const shutdown = subscriber.shutdown.bind(subscriber)\n\n  return () => {\n    if (unsubscribe !== null) {\n      unsubscribe()\n    }\n    shutdown()\n  }\n}\n","import FetchError from './fetch-error'\nimport graphqlWsSubscriber from './graphql-ws-subscriber'\n\nexport default function graphqlWsClient (url, init, query, variables, operationName, onNext, onError, onComplete) {\n  const abortController = new AbortController()\n\n  // Invoke fetch as a POST with the GraphQL content in the body.\n  fetch(url, {\n    method: 'POST',\n    signal: abortController.signal,\n    body: JSON.stringify({\n      query,\n      variables,\n      operationName\n    }),\n    ...init\n  })\n    .then(response => {\n      if (response.status === 200) {\n        // A 200 response is from a query or mutation.\n\n        response.json()\n          .then(json => {\n            onNext(json)\n            onComplete()\n          })\n          .catch(error => onError(error))\n      } else if (response.status === 201) {\n        // A 201 is the response for a subscription.\n\n        // The url for the event source is passed in the 'location' header.\n        const location = response.headers.get('location')\n        const index = location.indexOf('?')\n        const wsUrl = 'ws' + location.slice(4, index === -1 ? undefined : index)\n\n        const unsubscribe = graphqlWsSubscriber(wsUrl, query, variables, operationName, onNext, onError, onComplete)\n\n        abortController.signal.onabort = () => {\n          unsubscribe()\n        }\n      } else {\n        onError(new FetchError(response, 'Failed to execute GraphQL'))\n      }\n    })\n    .catch(error => {\n      onError(error)\n    })\n\n  // Return an unsubscribe function.\n  return () => {\n    abortController.abort()\n  }\n}\n","import FetchError from './fetch-error'\n\nexport default function graphqlClient (url, init, query, variables, operationName, onNext, onError, onComplete) {\n  const abortController = new AbortController()\n\n  // Invoke fetch as a POST with the GraphQL content in the body.\n  fetch(url, {\n    method: 'POST',\n    signal: abortController.signal,\n    body: JSON.stringify({\n      query,\n      variables,\n      operationName\n    }),\n    ...init\n  })\n    .then(response => {\n      if (response.status === 200) {\n        // A 200 response is from a query or mutation.\n\n        response.json()\n          .then(json => {\n            onNext(json)\n            onComplete()\n          })\n          .catch(error => onError(error))\n      } else if (response.status === 201) {\n        // A 201 is the response for a subscription.\n\n        // The url for the event source is passed in the 'location' header.\n        const location = response.headers.get('location')\n\n        const eventSource = new EventSource(location)\n\n        eventSource.onmessage = event => {\n          const data = JSON.parse(event.data)\n          onNext(data)\n        }\n\n        eventSource.onerror = error => {\n          onError(error)\n        }\n\n        abortController.signal.onabort = () => {\n          if (eventSource.readyState !== 2) {\n            eventSource.close()\n            onComplete()\n          }\n        }\n      } else {\n        onError(new FetchError(response, 'Failed to execute GraphQL'))\n      }\n    })\n    .catch(error => onError(error))\n\n  // Return an unsubscribe function.\n  return () => {\n    abortController.abort()\n  }\n}\n","export default function graphqlEventSourceSubscriber (url, query, variables, operationName, onNext, onError, onComplete) {\n  let subscriptionUrl = url + '?query=' + encodeURIComponent(query)\n  if (variables) {\n    subscriptionUrl += '&variables=' + encodeURIComponent(JSON.stringify(variables))\n  }\n  if (operationName) {\n    subscriptionUrl += '&operationName=' + encodeURIComponent(operationName)\n  }\n\n  const eventSource = new EventSource(subscriptionUrl)\n\n  eventSource.onmessage = event => {\n    const data = JSON.parse(event.data)\n    onNext(data)\n  }\n\n  eventSource.onerror = error => {\n    onError(error)\n  }\n\n  const abortController = new AbortController()\n  abortController.signal.onabort = () => {\n    if (eventSource.readyState !== 2) {\n      eventSource.close()\n      onComplete()\n    }\n  }\n\n  return abortController.abort\n}\n","import FetchError from './fetch-error'\n\nexport default function graphqlFetchClient (url, init, query, variables, operationName, onError, onSuccess) {\n  fetch(url, {\n    method: 'POST',\n    body: JSON.stringify({\n      query,\n      variables,\n      operationName\n    }),\n    ...init\n  })\n    .then(response => {\n      if (response.ok) {\n        response.json()\n          .then(json => {\n            onSuccess(json)\n          })\n          .catch(error => onError(error))\n      } else {\n        onError(new FetchError(response, 'Failed to execute GraphQL'))\n      }\n    })\n    .catch(error => onError(error))\n}\n","function makeWriteableStream (onNext, onError, onComplete) {\n  return new WritableStream({\n    write (chunk, controller) {\n      onNext(chunk)\n    },\n    close (controller) {\n      onComplete()\n    },\n    abort (reason) {\n      if (reason.name === 'AbortError') {\n        onComplete()\n      } else {\n        onError(reason)\n      }\n    }\n  })\n}\n\nfunction makeLineDecoder () {\n  // eslint-disable-next-line no-undef\n  return new TransformStream({\n    start (controller) {\n      controller.buf = ''\n      controller.pos = 0\n    },\n    transform (chunk, controller) {\n      controller.buf += chunk\n      while (controller.pos < controller.buf.length) {\n        if (controller.buf[controller.pos] === '\\n') {\n          const line = controller.buf.substring(0, controller.pos)\n          if (line !== '') {\n            controller.enqueue(line)\n          }\n          controller.buf = controller.buf.substring(controller.pos + 1)\n          controller.pos = 0\n        } else {\n          ++controller.pos\n        }\n      }\n    },\n    flush (controller) {\n      if (controller.pos !== 0) {\n        controller.enqueue(controller.buf)\n      }\n    }\n  })\n}\n\nexport default function graphqlStreamClient (url, init, query, variables, operationName, onNext, onError, onComplete) {\n  const body = JSON.stringify({\n    query, variables, operationName\n  })\n  const method = 'POST'\n  const abortController = new AbortController()\n\n  fetch(url, {\n    method,\n    headers: new Headers({\n      allow: method,\n      'content-type': 'application/json',\n      accept: 'application/json',\n      ...(init || {}).headers\n    }),\n    mode: 'cors',\n    body,\n    signal: abortController.signal,\n    ...init\n  })\n    .then(response => {\n      if (response.status === 200) {\n        // A streaming response is a subscription.\n        const lineDecoder = makeLineDecoder()\n        const writeableStream = makeWriteableStream(onNext, onError, onComplete)\n\n        response.body\n        // eslint-disable-next-line no-undef\n          .pipeThrough(new TextDecoderStream())\n          .pipeThrough(lineDecoder)\n          // eslint-disable-next-line no-undef\n          .pipeThrough(new TransformStream({\n            transform (chunk, controller) {\n              controller.enqueue(JSON.parse(chunk))\n            }\n          }))\n          .pipeTo(writeableStream)\n          .catch(() => {\n            // Errors are handled in the writeable stream\n          })\n      } else {\n        onError(new Error('Unhandled response'))\n      }\n    })\n    .catch(error => {\n      onError(error)\n    })\n\n  // Return a method to stop the request.\n  return () => abortController.abort()\n}\n"],"names":["FetchError","Error","[object Object]","response","params","super","captureStackTrace","this","name","GraphQLError","details","EventError","event","GQL","Subscriber","url","options","callback","protocols","nextId","subscriptions","Map","webSocket","WebSocket","onopen","send","JSON","stringify","type","payload","onclose","error","code","callbacks","Array","from","values","clear","onmessage","onMessage","bind","query","variables","operationName","id","toString","set","delete","close","data","parse","subscribe","get","errors","graphqlWsSubscriber","onNext","onError","onComplete","unsubscribe","subscriber","shutdown","graphqlWsClient","init","abortController","AbortController","fetch","method","signal","body","then","status","json","catch","location","headers","index","indexOf","slice","undefined","onabort","abort","eventSource","EventSource","onerror","readyState","subscriptionUrl","encodeURIComponent","onSuccess","ok","Headers","allow","content-type","accept","mode","lineDecoder","TransformStream","controller","buf","pos","chunk","length","line","substring","enqueue","writeableStream","WritableStream","reason","makeWriteableStream","pipeThrough","TextDecoderStream","pipeTo"],"mappings":"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"}